探討 在使用獨體模式處理多執行緒時

1.我們可能透過synchronized關鍵字，使得此方法具有執行緒的安全，但會使得效率低落，而失去多執行緒帶來的效能
而且在獨體模式之中，也就只有「第一次」獨體物件的建立時，才可能發生多執行緒競速的情況，而造成無法預期的錯誤
也因此最好能將第一次的建立，確保執行緒安全，而建立完成之後 也是一再重複的使用此獨體物件，就沒必要將整個方法
都宣告成synchronized

2.可以「率先」給定獨體物件的實體，不使用拖延實體化的方式
但這會面臨可能得先行消耗資源的問題，拖延實體化告訴我們，不需要此實體時就不需要先建立，當需要此實體在建立
但率先(eagerly)給定實體，就會先消耗資源，但可解決執行緒競速的情況，因為物件以給定實體，不會發生執行緒
同時建立兩種物件的情況，所以此時方法，就只需要不斷的將給定好的物件回傳，重複使用即可

3.使用「雙重檢查上鎖」(double-checked locking)，在方法中減少使用同步化
利用雙重檢查上鎖，首先檢查是否實體已建立，如果尚未建立，「才」進行同步化，只有「第一次才會同步化」

public class Singleton {
	private volatile static Singleton uniqueInstance;//使用volatile關鍵字，確保執行緒的改變，另一執行緒
	private Singleton() {}					//一定可見
	public static Singleton getInstance() {
		if(uniqueInstance == null) {	//檢查實體，如果不存在，才進入同步區塊
			synchronized(Singleton.class) {	//必須取得Singleton.class的物件鎖定
				if(uniqueInstance == null) {	//再檢查一次，否則如果當兩個執行緒都執行進入第一個if區塊，一個執行緒
					uniqueInstance = new Singleton();		//執行同步化區塊，生成實體，然後離開
				}						//再由另一個執行緒從原本的if區塊內往下執行
			}							//此時進入同步區塊後，沒有第二個if的檢查，將可能
		}							//再生成第二個物件，所以必須檢查第二次，確保仍然未生成實體
		return uniqueInstance;					//在建立實體，而有了volatile關鍵字，所以第一個執行緒將
	}								//uniqueInstance的改變另一個執行緒能馬上得知，確保資訊的更新
}								//此時就能達到在「第一次」的情況下確保執行緒安全，爾後的每一次
								//都能夠直接使得多執行緒直接進入此方法，將獨體不斷回傳使用
						//就能達到多執行緒帶來的效能提升